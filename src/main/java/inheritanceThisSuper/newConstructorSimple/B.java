package inheritanceThisSuper.newConstructorSimple;

public class B extends A {
    // default конструктора нет, поэтому создание конструктора со ссылкой super обязательно

    // Инициализация какого-либо поля (например, int i) до того, как отработал конструктор super(int i), невозможна.
    // Соответственно, ни одно поле не может быть передано из класса-наследника в конструктор super(int i). Необходимо
    // либо создать конструктор, который будет получать в качестве параметров эту необходимую i и передавать ее в
    // конструктор super(int i) для создания образца родителя например, это public B(int i)  {super(int i);}, либо
    // еще возможный вариант - создать статическое поле, которое будет инициализировано при создании класса (если
    // значение не указано, то оно будет инициализировано 0 или null):
    private static int i;

    public B() {
        super(i);
    }

    //    @Override // todo: Статический метод не переопределяется!!!!
    static void test1() { // todo: Если static в классе A, то должен быть static и в классе B, иначе это расценивается
        // как попытка переопределения/ Здесь модификатор static означает, что мы всего лишь ПРЯЧЕМ метод класса-родителя,
        // todo: это СОКРЫТИЕ МЕТОДОВ (hiding methods), см.:
        // http://info.javarush.ru/translation/2014/04/15/10-%D0%B7%D0%B0%D0%BC%D0%B5%D1%82%D0%BE%D0%BA-%D0%BE-
        // %D0%BC%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D0%B5-Static-%D0%B2-Java.html
// todo: это потому, что определение типа, откуда берется static метод, происходит НЕ в runtime (late binding), а при
// СОЗДАНИИ КЛАССА компилятором ("статические методы связываются [получают связь с типом] во время компиляции, в отличие
// от связывания виртуальных или не статических методов, которые связываются во время исполнения на реальном объекте")
        System.out.println("B.test1");
    }

    static void test2() {
//        super.test2(); // todo: из СТАТИЧЕСКОГО контекста НЕЛЬЗЯ обратиться к ИНСТАНСУ суперкласса
    }

    @Override
    protected B test3() throws Exception { // возвращаемый тип можно более узкий, поскольку B является также A
        System.out.println("B.test3");
        return new B();
    } // protected можно, поскольку в A этот метод package private

    @Override
    public Integer polymorph() throws RuntimeException { // а вот примитив int для возвращаемого значения не годится
        return 5;
    }

    @Override
    protected int polymorph2() { // todo: более широкий long нельзя, более узкий short нельзя (!???), только int (???)
        return 3;
    }
    // todo: при переопределении ---модификатор доступа можно расширять;
    // todo: ---возвращаемый тип можно сужать, но только ЕСЛИ ЭТО НЕ ПРИМИТИВ;
    // ---исключения можно менять в любую сторону, если UNCHECKED; можно убрать у ребенка; можно менять, если
    // todo: в родителе checked, а в ребенке unchecked; НАОБОРОТ НЕЛЬЗЯ!!! Нужно учесть также, что Exception is checked,
    // т.е. если в ребенке стоит checked исключение Exception, то и в родителе д.б. checked исключение!!!
    // todo: Т.Е. ИСКЛЮЧЕНИЯ МОЖНО МЕНЯТЬ В СТОРОНУ UNCHECKED, НО НЕ НАОБОРОТ (в полиморфизме, мы можем обращаться
    // к объекту-родителю, у которого unchecked exception, все в порядке, но если вдруг в runtime окажется, что
    // используется тип ребенка, а у ребенка оказалось checked исключение - будет кака, - это late binding, детка!)
    // todo: ЕСЛИ РЕБЕНОК throws CHECKED EXCEPTION, то и родитель обязательно должен бросать checked exception,
    // todo: ПРИЧЕМ БОЛЕЕ ШИРОКОЕ, ЧЕМ РЕБЕНОК. В отношении unchecked - можно менять в ЛЮБУЮ сторону.

    // todo: ВЫВОД: --- модификатор доступа м.расширять; возвращаемый тип (не примитив) и checked exception - сужать
    // иначе - противоречие контракту: компилятор согласился, что будет принимать такой-то тип, а ему в рантайме
    // предлагают более широкий, к которому нельзя свести тот, с которым он согласился 

    @Override
    public String toString() {
        return super.toString() + ". Here: B.toString() is worked.";
    }

    public void print() {
        System.out.println("The only B class method print() is worked here.");
    }
}
